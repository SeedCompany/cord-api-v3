// GENERATED by @gel/generate v0.6.2

import { DateTime } from 'luxon';
import { CalendarDate } from '~/common/temporal/calendar-date';
import * as gel from "gel";
import type * as $ from "./reflection";
import * as literal from "./literal";
import type * as _std from "./modules/std";
import type * as _sys from "./modules/sys";
import type * as _stdpg from "./modules/std/pg";
import type * as _stdnethttp from "./modules/std/net/http";
import type * as _stdnet from "./modules/std/net";
import type * as _stdfts from "./modules/std/fts";
import type * as _stdenc from "./modules/std/enc";
import type * as _stdcal from "./modules/std/cal";
import type * as _schema from "./modules/schema";
import type * as _default from "./modules/default";
import type * as _cfg from "./modules/cfg";
import type * as _User from "./modules/User";
import type * as _Project from "./modules/Project";
import type * as _ProgressReport from "./modules/ProgressReport";
import type * as _ProgressReportProductProgress from "./modules/ProgressReport/ProductProgress";
import type * as _Product from "./modules/Product";
import type * as _Post from "./modules/Post";
import type * as _Partnership from "./modules/Partnership";
import type * as _Partner from "./modules/Partner";
import type * as _Organization from "./modules/Organization";
import type * as _Location from "./modules/Location";
import type * as _Language from "./modules/Language";
import type * as _Ethnologue from "./modules/Ethnologue";
import type * as _Engagement from "./modules/Engagement";
import type * as _Budget from "./modules/Budget";
export type scalarAssignableBy<T extends $.ScalarType> =
  T extends _std.$number ? _std.$number : 
  T extends _sys.$VersionStage ? _sys.$VersionStage : 
  T extends _sys.$TransactionIsolation ? _sys.$TransactionIsolation : 
  T extends _sys.$TransactionDeferrability ? _sys.$TransactionDeferrability : 
  T extends _sys.$TransactionAccessMode ? _sys.$TransactionAccessMode : 
  T extends _sys.$QueryType ? _sys.$QueryType : 
  T extends _sys.$OutputFormat ? _sys.$OutputFormat : 
  T extends _std.$uuid ? _std.$uuid : 
  T extends _stdpg.$timestamptz ? _stdpg.$timestamptz : 
  T extends _stdpg.$timestamp ? _stdpg.$timestamp : 
  T extends _stdpg.$json ? _stdpg.$json : 
  T extends _stdpg.$interval ? _stdpg.$interval : 
  T extends _stdpg.$date ? _stdpg.$date : 
  T extends _stdnethttp.$Method ? _stdnethttp.$Method : 
  T extends _stdnet.$RequestState ? _stdnet.$RequestState : 
  T extends _stdnet.$RequestFailureKind ? _stdnet.$RequestFailureKind : 
  T extends _std.$int64 ? _std.$int64 : 
  T extends _std.$int16 ? _std.$int16 : 
  T extends _stdfts.$document ? _stdfts.$document : 
  T extends _stdfts.$Weight ? _stdfts.$Weight : 
  T extends _stdfts.$PGLanguage ? _stdfts.$PGLanguage : 
  T extends _stdfts.$LuceneLanguage ? _stdfts.$LuceneLanguage : 
  T extends _stdfts.$Language ? _stdfts.$Language : 
  T extends _stdfts.$ElasticLanguage ? _stdfts.$ElasticLanguage : 
  T extends _std.$float64 ? _std.$float64 : 
  T extends _std.$float32 ? _std.$float32 : 
  T extends _stdenc.$Base64Alphabet ? _stdenc.$Base64Alphabet : 
  T extends _std.$duration ? _std.$duration : 
  T extends _std.$decimal ? _std.$decimalλIAssignableBy : 
  T extends _std.$datetime ? _std.$datetime : 
  T extends _stdcal.$relative_duration ? _stdcal.$relative_durationλIAssignableBy : 
  T extends _stdcal.$local_time ? _stdcal.$local_time : 
  T extends _stdcal.$local_datetime ? _stdcal.$local_datetimeλIAssignableBy : 
  T extends _stdcal.$local_date ? _stdcal.$local_date : 
  T extends _stdcal.$date_duration ? _stdcal.$date_duration : 
  T extends _std.$bytes ? _std.$bytes : 
  T extends _std.$bool ? _std.$bool : 
  T extends _std.$bigint ? _std.$bigint : 
  T extends _std.$JsonEmpty ? _std.$JsonEmpty : 
  T extends _std.$Endian ? _std.$Endian : 
  T extends _schema.$Volatility ? _schema.$Volatility : 
  T extends _schema.$TypeModifier ? _schema.$TypeModifier : 
  T extends _schema.$TriggerTiming ? _schema.$TriggerTiming : 
  T extends _schema.$TriggerScope ? _schema.$TriggerScope : 
  T extends _schema.$TriggerKind ? _schema.$TriggerKind : 
  T extends _schema.$TargetDeleteAction ? _schema.$TargetDeleteAction : 
  T extends _schema.$SourceDeleteAction ? _schema.$SourceDeleteAction : 
  T extends _schema.$RewriteKind ? _schema.$RewriteKind : 
  T extends _schema.$ParameterKind ? _schema.$ParameterKind : 
  T extends _schema.$OperatorKind ? _schema.$OperatorKind : 
  T extends _schema.$MigrationGeneratedBy ? _schema.$MigrationGeneratedBy : 
  T extends _schema.$IndexDeferrability ? _schema.$IndexDeferrability : 
  T extends _schema.$Cardinality ? _schema.$Cardinality : 
  T extends _schema.$AccessPolicyAction ? _schema.$AccessPolicyAction : 
  T extends _schema.$AccessKind ? _schema.$AccessKind : 
  T extends _default.$population ? _default.$population : 
  T extends _std.$int32 ? _std.$int32 : 
  T extends _default.$nanoid ? _default.$nanoid : 
  T extends _default.$currentRoles ? _default.$currentRoles : 
  T extends _default.$Sens ? _default.$Sens : 
  T extends _default.$Sensitivity ? _default.$Sensitivity : 
  T extends _default.$Role ? _default.$Role : 
  T extends _default.$RichText ? _default.$RichText : 
  T extends _std.$json ? _std.$json : 
  T extends _default.$ReportPeriod ? _default.$ReportPeriod : 
  T extends _cfg.$memory ? _cfg.$memory : 
  T extends _cfg.$StoreMigrationSDL ? _cfg.$StoreMigrationSDL : 
  T extends _cfg.$SMTPSecurity ? _cfg.$SMTPSecurity : 
  T extends _cfg.$QueryStatsOption ? _cfg.$QueryStatsOption : 
  T extends _cfg.$QueryCacheMode ? _cfg.$QueryCacheMode : 
  T extends _cfg.$ConnectionTransport ? _cfg.$ConnectionTransport : 
  T extends _cfg.$AllowBareDDL ? _cfg.$AllowBareDDL : 
  T extends _User.$Status ? _User.$Status : 
  T extends _User.$Degree ? _User.$Degree : 
  T extends _Project.$Type ? _Project.$Type : 
  T extends _Project.$Step ? _Project.$Step : 
  T extends _Project.$Status ? _Project.$Status : 
  T extends _ProgressReport.$Status ? _ProgressReport.$Status : 
  T extends _ProgressReportProductProgress.$Variant ? _ProgressReportProductProgress.$Variant : 
  T extends _ProgressReportProductProgress.$Period ? _ProgressReportProductProgress.$Period : 
  T extends _Product.$Step ? _Product.$Step : 
  T extends _Product.$Purpose ? _Product.$Purpose : 
  T extends _Product.$ProgressMeasurement ? _Product.$ProgressMeasurement : 
  T extends _Product.$Methodology ? _Product.$Methodology : 
  T extends _Product.$Medium ? _Product.$Medium : 
  T extends _Post.$Type ? _Post.$Type : 
  T extends _Post.$Shareability ? _Post.$Shareability : 
  T extends _Partnership.$FinancialReportingType ? _Partnership.$FinancialReportingType : 
  T extends _Partnership.$AgreementStatus ? _Partnership.$AgreementStatus : 
  T extends _Partner.$Type ? _Partner.$Type : 
  T extends _Organization.$Type ? _Organization.$Type : 
  T extends _Organization.$Reach ? _Organization.$Reach : 
  T extends _Location.$Type ? _Location.$Type : 
  T extends _Location.$IsoAlpha3Code ? _Location.$IsoAlpha3Code : 
  T extends _Language.$Milestone ? _Language.$Milestone : 
  T extends _Ethnologue.$code ? _Ethnologue.$code : 
  T extends _std.$str ? _std.$str : 
  T extends _Engagement.$Status ? _Engagement.$Status : 
  T extends _Engagement.$InternPosition ? _Engagement.$InternPosition : 
  T extends _Engagement.$AIAssistedTranslation ? _Engagement.$AIAssistedTranslation : 
  T extends _Budget.$Status ? _Budget.$Status : 
  never

export type scalarCastableFrom<T extends $.ScalarType> =
  T extends _std.$number ? _std.$number : 
  T extends _sys.$VersionStage ? _sys.$VersionStage : 
  T extends _sys.$TransactionIsolation ? _sys.$TransactionIsolation : 
  T extends _sys.$TransactionDeferrability ? _sys.$TransactionDeferrability : 
  T extends _sys.$TransactionAccessMode ? _sys.$TransactionAccessMode : 
  T extends _sys.$QueryType ? _sys.$QueryType : 
  T extends _sys.$OutputFormat ? _sys.$OutputFormat : 
  T extends _std.$uuid ? _std.$uuid : 
  T extends _stdpg.$timestamptz ? _stdpg.$timestamptz : 
  T extends _stdpg.$timestamp ? _stdpg.$timestamp : 
  T extends _stdpg.$json ? _stdpg.$json : 
  T extends _stdpg.$interval ? _stdpg.$interval : 
  T extends _stdpg.$date ? _stdpg.$date : 
  T extends _stdnethttp.$Method ? _stdnethttp.$Method : 
  T extends _stdnet.$RequestState ? _stdnet.$RequestState : 
  T extends _stdnet.$RequestFailureKind ? _stdnet.$RequestFailureKind : 
  T extends _std.$int64 ? _std.$int64 : 
  T extends _std.$int16 ? _std.$int16 : 
  T extends _stdfts.$document ? _stdfts.$document : 
  T extends _stdfts.$Weight ? _stdfts.$Weight : 
  T extends _stdfts.$PGLanguage ? _stdfts.$PGLanguage : 
  T extends _stdfts.$LuceneLanguage ? _stdfts.$LuceneLanguage : 
  T extends _stdfts.$Language ? _stdfts.$Language : 
  T extends _stdfts.$ElasticLanguage ? _stdfts.$ElasticLanguage : 
  T extends _std.$float64 ? _std.$float64 : 
  T extends _std.$float32 ? _std.$float32 : 
  T extends _stdenc.$Base64Alphabet ? _stdenc.$Base64Alphabet : 
  T extends _std.$duration ? _std.$duration : 
  T extends _std.$decimal ? _std.$decimalλICastableTo : 
  T extends _std.$datetime ? _std.$datetime : 
  T extends _stdcal.$relative_duration ? _stdcal.$relative_durationλICastableTo : 
  T extends _stdcal.$local_time ? _stdcal.$local_time : 
  T extends _stdcal.$local_datetime ? _stdcal.$local_datetimeλICastableTo : 
  T extends _stdcal.$local_date ? _stdcal.$local_date : 
  T extends _stdcal.$date_duration ? _stdcal.$date_duration : 
  T extends _std.$bytes ? _std.$bytes : 
  T extends _std.$bool ? _std.$bool : 
  T extends _std.$bigint ? _std.$bigint : 
  T extends _std.$JsonEmpty ? _std.$JsonEmpty : 
  T extends _std.$Endian ? _std.$Endian : 
  T extends _schema.$Volatility ? _schema.$Volatility : 
  T extends _schema.$TypeModifier ? _schema.$TypeModifier : 
  T extends _schema.$TriggerTiming ? _schema.$TriggerTiming : 
  T extends _schema.$TriggerScope ? _schema.$TriggerScope : 
  T extends _schema.$TriggerKind ? _schema.$TriggerKind : 
  T extends _schema.$TargetDeleteAction ? _schema.$TargetDeleteAction : 
  T extends _schema.$SourceDeleteAction ? _schema.$SourceDeleteAction : 
  T extends _schema.$RewriteKind ? _schema.$RewriteKind : 
  T extends _schema.$ParameterKind ? _schema.$ParameterKind : 
  T extends _schema.$OperatorKind ? _schema.$OperatorKind : 
  T extends _schema.$MigrationGeneratedBy ? _schema.$MigrationGeneratedBy : 
  T extends _schema.$IndexDeferrability ? _schema.$IndexDeferrability : 
  T extends _schema.$Cardinality ? _schema.$Cardinality : 
  T extends _schema.$AccessPolicyAction ? _schema.$AccessPolicyAction : 
  T extends _schema.$AccessKind ? _schema.$AccessKind : 
  T extends _default.$population ? _default.$population : 
  T extends _std.$int32 ? _std.$int32 : 
  T extends _default.$nanoid ? _default.$nanoid : 
  T extends _default.$currentRoles ? _default.$currentRoles : 
  T extends _default.$Sens ? _default.$Sens : 
  T extends _default.$Sensitivity ? _default.$Sensitivity : 
  T extends _default.$Role ? _default.$Role : 
  T extends _default.$RichText ? _default.$RichText : 
  T extends _std.$json ? _std.$json : 
  T extends _default.$ReportPeriod ? _default.$ReportPeriod : 
  T extends _cfg.$memory ? _cfg.$memory : 
  T extends _cfg.$StoreMigrationSDL ? _cfg.$StoreMigrationSDL : 
  T extends _cfg.$SMTPSecurity ? _cfg.$SMTPSecurity : 
  T extends _cfg.$QueryStatsOption ? _cfg.$QueryStatsOption : 
  T extends _cfg.$QueryCacheMode ? _cfg.$QueryCacheMode : 
  T extends _cfg.$ConnectionTransport ? _cfg.$ConnectionTransport : 
  T extends _cfg.$AllowBareDDL ? _cfg.$AllowBareDDL : 
  T extends _User.$Status ? _User.$Status : 
  T extends _User.$Degree ? _User.$Degree : 
  T extends _Project.$Type ? _Project.$Type : 
  T extends _Project.$Step ? _Project.$Step : 
  T extends _Project.$Status ? _Project.$Status : 
  T extends _ProgressReport.$Status ? _ProgressReport.$Status : 
  T extends _ProgressReportProductProgress.$Variant ? _ProgressReportProductProgress.$Variant : 
  T extends _ProgressReportProductProgress.$Period ? _ProgressReportProductProgress.$Period : 
  T extends _Product.$Step ? _Product.$Step : 
  T extends _Product.$Purpose ? _Product.$Purpose : 
  T extends _Product.$ProgressMeasurement ? _Product.$ProgressMeasurement : 
  T extends _Product.$Methodology ? _Product.$Methodology : 
  T extends _Product.$Medium ? _Product.$Medium : 
  T extends _Post.$Type ? _Post.$Type : 
  T extends _Post.$Shareability ? _Post.$Shareability : 
  T extends _Partnership.$FinancialReportingType ? _Partnership.$FinancialReportingType : 
  T extends _Partnership.$AgreementStatus ? _Partnership.$AgreementStatus : 
  T extends _Partner.$Type ? _Partner.$Type : 
  T extends _Organization.$Type ? _Organization.$Type : 
  T extends _Organization.$Reach ? _Organization.$Reach : 
  T extends _Location.$Type ? _Location.$Type : 
  T extends _Location.$IsoAlpha3Code ? _Location.$IsoAlpha3Code : 
  T extends _Language.$Milestone ? _Language.$Milestone : 
  T extends _Ethnologue.$code ? _Ethnologue.$code : 
  T extends _std.$str ? _std.$str : 
  T extends _Engagement.$Status ? _Engagement.$Status : 
  T extends _Engagement.$InternPosition ? _Engagement.$InternPosition : 
  T extends _Engagement.$AIAssistedTranslation ? _Engagement.$AIAssistedTranslation : 
  T extends _Budget.$Status ? _Budget.$Status : 
  never

type getSharedParentScalar<A, B> =
  A extends _std.$number ?
    B extends _std.$number ?
    B
    :
    never
  :
  A extends _sys.$VersionStage ?
    B extends _sys.$VersionStage ?
    B
    :
    never
  :
  A extends _sys.$TransactionIsolation ?
    B extends _sys.$TransactionIsolation ?
    B
    :
    never
  :
  A extends _sys.$TransactionDeferrability ?
    B extends _sys.$TransactionDeferrability ?
    B
    :
    never
  :
  A extends _sys.$TransactionAccessMode ?
    B extends _sys.$TransactionAccessMode ?
    B
    :
    never
  :
  A extends _sys.$QueryType ?
    B extends _sys.$QueryType ?
    B
    :
    never
  :
  A extends _sys.$OutputFormat ?
    B extends _sys.$OutputFormat ?
    B
    :
    never
  :
  A extends _std.$uuid ?
    B extends _std.$uuid ?
    B
    :
    never
  :
  A extends _stdpg.$timestamptz ?
    B extends _stdpg.$timestamptz ?
    B
    :
    never
  :
  A extends _stdpg.$timestamp ?
    B extends _stdpg.$timestamp ?
    B
    :
    never
  :
  A extends _stdpg.$json ?
    B extends _stdpg.$json ?
    B
    :
    never
  :
  A extends _stdpg.$interval ?
    B extends _stdpg.$interval ?
    B
    :
    never
  :
  A extends _stdpg.$date ?
    B extends _stdpg.$date ?
    B
    :
    never
  :
  A extends _stdnethttp.$Method ?
    B extends _stdnethttp.$Method ?
    B
    :
    never
  :
  A extends _stdnet.$RequestState ?
    B extends _stdnet.$RequestState ?
    B
    :
    never
  :
  A extends _stdnet.$RequestFailureKind ?
    B extends _stdnet.$RequestFailureKind ?
    B
    :
    never
  :
  A extends _std.$int64 ?
    B extends _std.$int64 ?
    B
    :
    never
  :
  A extends _std.$int16 ?
    B extends _std.$int16 ?
    B
    :
    never
  :
  A extends _stdfts.$document ?
    B extends _stdfts.$document ?
    B
    :
    never
  :
  A extends _stdfts.$Weight ?
    B extends _stdfts.$Weight ?
    B
    :
    never
  :
  A extends _stdfts.$PGLanguage ?
    B extends _stdfts.$PGLanguage ?
    B
    :
    never
  :
  A extends _stdfts.$LuceneLanguage ?
    B extends _stdfts.$LuceneLanguage ?
    B
    :
    never
  :
  A extends _stdfts.$Language ?
    B extends _stdfts.$Language ?
    B
    :
    never
  :
  A extends _stdfts.$ElasticLanguage ?
    B extends _stdfts.$ElasticLanguage ?
    B
    :
    never
  :
  A extends _std.$float64 ?
    B extends _std.$float64 ?
    B
    :
    never
  :
  A extends _std.$float32 ?
    B extends _std.$float32 ?
    B
    :
    never
  :
  A extends _stdenc.$Base64Alphabet ?
    B extends _stdenc.$Base64Alphabet ?
    B
    :
    never
  :
  A extends _std.$duration ?
    B extends _std.$duration ?
    B
    :
    never
  :
  A extends _std.$decimal ?
    B extends _std.$decimal ?
    B
    :
    B extends _std.$bigint ?
    A
    :
    never
  :
  A extends _std.$datetime ?
    B extends _std.$datetime ?
    B
    :
    never
  :
  A extends _stdcal.$relative_duration ?
    B extends _stdcal.$relative_duration ?
    B
    :
    B extends _stdcal.$date_duration ?
    A
    :
    never
  :
  A extends _stdcal.$local_time ?
    B extends _stdcal.$local_time ?
    B
    :
    never
  :
  A extends _stdcal.$local_datetime ?
    B extends _stdcal.$local_datetime ?
    B
    :
    B extends _stdcal.$local_date ?
    A
    :
    never
  :
  A extends _stdcal.$local_date ?
    B extends _stdcal.$local_datetime ?
    B
    :
    B extends _stdcal.$local_date ?
    B
    :
    never
  :
  A extends _stdcal.$date_duration ?
    B extends _stdcal.$relative_duration ?
    B
    :
    B extends _stdcal.$date_duration ?
    B
    :
    never
  :
  A extends _std.$bytes ?
    B extends _std.$bytes ?
    B
    :
    never
  :
  A extends _std.$bool ?
    B extends _std.$bool ?
    B
    :
    never
  :
  A extends _std.$bigint ?
    B extends _std.$decimal ?
    B
    :
    B extends _std.$bigint ?
    B
    :
    never
  :
  A extends _std.$JsonEmpty ?
    B extends _std.$JsonEmpty ?
    B
    :
    never
  :
  A extends _std.$Endian ?
    B extends _std.$Endian ?
    B
    :
    never
  :
  A extends _schema.$Volatility ?
    B extends _schema.$Volatility ?
    B
    :
    never
  :
  A extends _schema.$TypeModifier ?
    B extends _schema.$TypeModifier ?
    B
    :
    never
  :
  A extends _schema.$TriggerTiming ?
    B extends _schema.$TriggerTiming ?
    B
    :
    never
  :
  A extends _schema.$TriggerScope ?
    B extends _schema.$TriggerScope ?
    B
    :
    never
  :
  A extends _schema.$TriggerKind ?
    B extends _schema.$TriggerKind ?
    B
    :
    never
  :
  A extends _schema.$TargetDeleteAction ?
    B extends _schema.$TargetDeleteAction ?
    B
    :
    never
  :
  A extends _schema.$SourceDeleteAction ?
    B extends _schema.$SourceDeleteAction ?
    B
    :
    never
  :
  A extends _schema.$RewriteKind ?
    B extends _schema.$RewriteKind ?
    B
    :
    never
  :
  A extends _schema.$ParameterKind ?
    B extends _schema.$ParameterKind ?
    B
    :
    never
  :
  A extends _schema.$OperatorKind ?
    B extends _schema.$OperatorKind ?
    B
    :
    never
  :
  A extends _schema.$MigrationGeneratedBy ?
    B extends _schema.$MigrationGeneratedBy ?
    B
    :
    never
  :
  A extends _schema.$IndexDeferrability ?
    B extends _schema.$IndexDeferrability ?
    B
    :
    never
  :
  A extends _schema.$Cardinality ?
    B extends _schema.$Cardinality ?
    B
    :
    never
  :
  A extends _schema.$AccessPolicyAction ?
    B extends _schema.$AccessPolicyAction ?
    B
    :
    never
  :
  A extends _schema.$AccessKind ?
    B extends _schema.$AccessKind ?
    B
    :
    never
  :
  A extends _default.$population ?
    B extends _default.$population ?
    B
    :
    never
  :
  A extends _std.$int32 ?
    B extends _std.$int32 ?
    B
    :
    never
  :
  A extends _default.$nanoid ?
    B extends _default.$nanoid ?
    B
    :
    never
  :
  A extends _default.$currentRoles ?
    B extends _default.$currentRoles ?
    B
    :
    never
  :
  A extends _default.$Sens ?
    B extends _default.$Sens ?
    B
    :
    never
  :
  A extends _default.$Sensitivity ?
    B extends _default.$Sensitivity ?
    B
    :
    never
  :
  A extends _default.$Role ?
    B extends _default.$Role ?
    B
    :
    never
  :
  A extends _default.$RichText ?
    B extends _default.$RichText ?
    B
    :
    never
  :
  A extends _std.$json ?
    B extends _std.$json ?
    B
    :
    never
  :
  A extends _default.$ReportPeriod ?
    B extends _default.$ReportPeriod ?
    B
    :
    never
  :
  A extends _cfg.$memory ?
    B extends _cfg.$memory ?
    B
    :
    never
  :
  A extends _cfg.$StoreMigrationSDL ?
    B extends _cfg.$StoreMigrationSDL ?
    B
    :
    never
  :
  A extends _cfg.$SMTPSecurity ?
    B extends _cfg.$SMTPSecurity ?
    B
    :
    never
  :
  A extends _cfg.$QueryStatsOption ?
    B extends _cfg.$QueryStatsOption ?
    B
    :
    never
  :
  A extends _cfg.$QueryCacheMode ?
    B extends _cfg.$QueryCacheMode ?
    B
    :
    never
  :
  A extends _cfg.$ConnectionTransport ?
    B extends _cfg.$ConnectionTransport ?
    B
    :
    never
  :
  A extends _cfg.$AllowBareDDL ?
    B extends _cfg.$AllowBareDDL ?
    B
    :
    never
  :
  A extends _User.$Status ?
    B extends _User.$Status ?
    B
    :
    never
  :
  A extends _User.$Degree ?
    B extends _User.$Degree ?
    B
    :
    never
  :
  A extends _Project.$Type ?
    B extends _Project.$Type ?
    B
    :
    never
  :
  A extends _Project.$Step ?
    B extends _Project.$Step ?
    B
    :
    never
  :
  A extends _Project.$Status ?
    B extends _Project.$Status ?
    B
    :
    never
  :
  A extends _ProgressReport.$Status ?
    B extends _ProgressReport.$Status ?
    B
    :
    never
  :
  A extends _ProgressReportProductProgress.$Variant ?
    B extends _ProgressReportProductProgress.$Variant ?
    B
    :
    never
  :
  A extends _ProgressReportProductProgress.$Period ?
    B extends _ProgressReportProductProgress.$Period ?
    B
    :
    never
  :
  A extends _Product.$Step ?
    B extends _Product.$Step ?
    B
    :
    never
  :
  A extends _Product.$Purpose ?
    B extends _Product.$Purpose ?
    B
    :
    never
  :
  A extends _Product.$ProgressMeasurement ?
    B extends _Product.$ProgressMeasurement ?
    B
    :
    never
  :
  A extends _Product.$Methodology ?
    B extends _Product.$Methodology ?
    B
    :
    never
  :
  A extends _Product.$Medium ?
    B extends _Product.$Medium ?
    B
    :
    never
  :
  A extends _Post.$Type ?
    B extends _Post.$Type ?
    B
    :
    never
  :
  A extends _Post.$Shareability ?
    B extends _Post.$Shareability ?
    B
    :
    never
  :
  A extends _Partnership.$FinancialReportingType ?
    B extends _Partnership.$FinancialReportingType ?
    B
    :
    never
  :
  A extends _Partnership.$AgreementStatus ?
    B extends _Partnership.$AgreementStatus ?
    B
    :
    never
  :
  A extends _Partner.$Type ?
    B extends _Partner.$Type ?
    B
    :
    never
  :
  A extends _Organization.$Type ?
    B extends _Organization.$Type ?
    B
    :
    never
  :
  A extends _Organization.$Reach ?
    B extends _Organization.$Reach ?
    B
    :
    never
  :
  A extends _Location.$Type ?
    B extends _Location.$Type ?
    B
    :
    never
  :
  A extends _Location.$IsoAlpha3Code ?
    B extends _Location.$IsoAlpha3Code ?
    B
    :
    never
  :
  A extends _Language.$Milestone ?
    B extends _Language.$Milestone ?
    B
    :
    never
  :
  A extends _Ethnologue.$code ?
    B extends _Ethnologue.$code ?
    B
    :
    never
  :
  A extends _std.$str ?
    B extends _std.$str ?
    B
    :
    never
  :
  A extends _Engagement.$Status ?
    B extends _Engagement.$Status ?
    B
    :
    never
  :
  A extends _Engagement.$InternPosition ?
    B extends _Engagement.$InternPosition ?
    B
    :
    never
  :
  A extends _Engagement.$AIAssistedTranslation ?
    B extends _Engagement.$AIAssistedTranslation ?
    B
    :
    never
  :
  A extends _Budget.$Status ?
    B extends _Budget.$Status ?
    B
    :
    never
  :
never

function getSharedParentScalar<A extends $.ScalarType, B extends $.ScalarType>(a: A, b: B): A | B {
  a = (a as any).__casttype__ || a;
  b = (b as any).__casttype__ || b;
  if (a.__name__ === "std::number") {
    if(b.__name__ === "std::number") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::VersionStage") {
    if(b.__name__ === "sys::VersionStage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::TransactionIsolation") {
    if(b.__name__ === "sys::TransactionIsolation") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::TransactionDeferrability") {
    if(b.__name__ === "sys::TransactionDeferrability") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::TransactionAccessMode") {
    if(b.__name__ === "sys::TransactionAccessMode") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::QueryType") {
    if(b.__name__ === "sys::QueryType") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "sys::OutputFormat") {
    if(b.__name__ === "sys::OutputFormat") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::uuid") {
    if(b.__name__ === "std::uuid") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::pg::timestamptz") {
    if(b.__name__ === "std::pg::timestamptz") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::pg::timestamp") {
    if(b.__name__ === "std::pg::timestamp") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::pg::json") {
    if(b.__name__ === "std::pg::json") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::pg::interval") {
    if(b.__name__ === "std::pg::interval") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::pg::date") {
    if(b.__name__ === "std::pg::date") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::net::http::Method") {
    if(b.__name__ === "std::net::http::Method") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::net::RequestState") {
    if(b.__name__ === "std::net::RequestState") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::net::RequestFailureKind") {
    if(b.__name__ === "std::net::RequestFailureKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::int64") {
    if(b.__name__ === "std::int64") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::int16") {
    if(b.__name__ === "std::int16") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::fts::document") {
    if(b.__name__ === "std::fts::document") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::fts::Weight") {
    if(b.__name__ === "std::fts::Weight") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::fts::PGLanguage") {
    if(b.__name__ === "std::fts::PGLanguage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::fts::LuceneLanguage") {
    if(b.__name__ === "std::fts::LuceneLanguage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::fts::Language") {
    if(b.__name__ === "std::fts::Language") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::fts::ElasticLanguage") {
    if(b.__name__ === "std::fts::ElasticLanguage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::float64") {
    if(b.__name__ === "std::float64") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::float32") {
    if(b.__name__ === "std::float32") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::enc::Base64Alphabet") {
    if(b.__name__ === "std::enc::Base64Alphabet") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::duration") {
    if(b.__name__ === "std::duration") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::decimal") {
    if(b.__name__ === "std::decimal") {
      return b;
    }
    if(b.__name__ === "std::bigint") {
      return a;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::datetime") {
    if(b.__name__ === "std::datetime") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::cal::relative_duration") {
    if(b.__name__ === "std::cal::relative_duration") {
      return b;
    }
    if(b.__name__ === "std::cal::date_duration") {
      return a;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::cal::local_time") {
    if(b.__name__ === "std::cal::local_time") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::cal::local_datetime") {
    if(b.__name__ === "std::cal::local_datetime") {
      return b;
    }
    if(b.__name__ === "std::cal::local_date") {
      return a;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::cal::local_date") {
    if(b.__name__ === "std::cal::local_datetime") {
      return b;
    }
    if(b.__name__ === "std::cal::local_date") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::cal::date_duration") {
    if(b.__name__ === "std::cal::relative_duration") {
      return b;
    }
    if(b.__name__ === "std::cal::date_duration") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::bytes") {
    if(b.__name__ === "std::bytes") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::bool") {
    if(b.__name__ === "std::bool") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::bigint") {
    if(b.__name__ === "std::decimal") {
      return b;
    }
    if(b.__name__ === "std::bigint") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::JsonEmpty") {
    if(b.__name__ === "std::JsonEmpty") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::Endian") {
    if(b.__name__ === "std::Endian") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::Volatility") {
    if(b.__name__ === "schema::Volatility") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TypeModifier") {
    if(b.__name__ === "schema::TypeModifier") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TriggerTiming") {
    if(b.__name__ === "schema::TriggerTiming") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TriggerScope") {
    if(b.__name__ === "schema::TriggerScope") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TriggerKind") {
    if(b.__name__ === "schema::TriggerKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::TargetDeleteAction") {
    if(b.__name__ === "schema::TargetDeleteAction") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::SourceDeleteAction") {
    if(b.__name__ === "schema::SourceDeleteAction") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::RewriteKind") {
    if(b.__name__ === "schema::RewriteKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::ParameterKind") {
    if(b.__name__ === "schema::ParameterKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::OperatorKind") {
    if(b.__name__ === "schema::OperatorKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::MigrationGeneratedBy") {
    if(b.__name__ === "schema::MigrationGeneratedBy") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::IndexDeferrability") {
    if(b.__name__ === "schema::IndexDeferrability") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::Cardinality") {
    if(b.__name__ === "schema::Cardinality") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::AccessPolicyAction") {
    if(b.__name__ === "schema::AccessPolicyAction") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "schema::AccessKind") {
    if(b.__name__ === "schema::AccessKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "default::population") {
    if(b.__name__ === "default::population") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::int32") {
    if(b.__name__ === "std::int32") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "default::nanoid") {
    if(b.__name__ === "default::nanoid") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "default::currentRoles") {
    if(b.__name__ === "default::currentRoles") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "default::Sens") {
    if(b.__name__ === "default::Sens") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "default::Sensitivity") {
    if(b.__name__ === "default::Sensitivity") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "default::Role") {
    if(b.__name__ === "default::Role") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "default::RichText") {
    if(b.__name__ === "default::RichText") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::json") {
    if(b.__name__ === "std::json") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "default::ReportPeriod") {
    if(b.__name__ === "default::ReportPeriod") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::memory") {
    if(b.__name__ === "cfg::memory") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::StoreMigrationSDL") {
    if(b.__name__ === "cfg::StoreMigrationSDL") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::SMTPSecurity") {
    if(b.__name__ === "cfg::SMTPSecurity") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::QueryStatsOption") {
    if(b.__name__ === "cfg::QueryStatsOption") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::QueryCacheMode") {
    if(b.__name__ === "cfg::QueryCacheMode") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::ConnectionTransport") {
    if(b.__name__ === "cfg::ConnectionTransport") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "cfg::AllowBareDDL") {
    if(b.__name__ === "cfg::AllowBareDDL") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "User::Status") {
    if(b.__name__ === "User::Status") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "User::Degree") {
    if(b.__name__ === "User::Degree") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Project::Type") {
    if(b.__name__ === "Project::Type") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Project::Step") {
    if(b.__name__ === "Project::Step") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Project::Status") {
    if(b.__name__ === "Project::Status") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "ProgressReport::Status") {
    if(b.__name__ === "ProgressReport::Status") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "ProgressReport::ProductProgress::Variant") {
    if(b.__name__ === "ProgressReport::ProductProgress::Variant") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "ProgressReport::ProductProgress::Period") {
    if(b.__name__ === "ProgressReport::ProductProgress::Period") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Product::Step") {
    if(b.__name__ === "Product::Step") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Product::Purpose") {
    if(b.__name__ === "Product::Purpose") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Product::ProgressMeasurement") {
    if(b.__name__ === "Product::ProgressMeasurement") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Product::Methodology") {
    if(b.__name__ === "Product::Methodology") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Product::Medium") {
    if(b.__name__ === "Product::Medium") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Post::Type") {
    if(b.__name__ === "Post::Type") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Post::Shareability") {
    if(b.__name__ === "Post::Shareability") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Partnership::FinancialReportingType") {
    if(b.__name__ === "Partnership::FinancialReportingType") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Partnership::AgreementStatus") {
    if(b.__name__ === "Partnership::AgreementStatus") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Partner::Type") {
    if(b.__name__ === "Partner::Type") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Organization::Type") {
    if(b.__name__ === "Organization::Type") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Organization::Reach") {
    if(b.__name__ === "Organization::Reach") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Location::Type") {
    if(b.__name__ === "Location::Type") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Location::IsoAlpha3Code") {
    if(b.__name__ === "Location::IsoAlpha3Code") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Language::Milestone") {
    if(b.__name__ === "Language::Milestone") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Ethnologue::code") {
    if(b.__name__ === "Ethnologue::code") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "std::str") {
    if(b.__name__ === "std::str") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Engagement::Status") {
    if(b.__name__ === "Engagement::Status") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Engagement::InternPosition") {
    if(b.__name__ === "Engagement::InternPosition") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Engagement::AIAssistedTranslation") {
    if(b.__name__ === "Engagement::AIAssistedTranslation") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  if (a.__name__ === "Budget::Status") {
    if(b.__name__ === "Budget::Status") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
    }
  throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
}

const implicitCastMap = new Map<string, Set<string>>([
  ["std::cal::date_duration", new Set(["std::cal::relative_duration"])],
  ["std::cal::local_date", new Set(["std::cal::local_datetime"])],
  ["std::bigint", new Set(["std::decimal"])],
]);
function isImplicitlyCastableTo(from: string, to: string): boolean {
  const _a = implicitCastMap.get(from),
        _b = _a != null ? _a.has(to) : null;
  return _b != null ? _b : false;
};

export type scalarLiterals =
  | number
  | string
  | boolean
  | bigint
  | Uint8Array
  | DateTime
  | gel.Duration
  | gel.ConfigMemory
  | Float32Array
  | gel.LocalDateTime
  | CalendarDate
  | gel.LocalTime
  | gel.RelativeDuration
  | gel.DateDuration
  | gel.LocalDate
  | gel.Range<any> | gel.MultiRange<any>;

type getTsType<T extends $.BaseType> = T extends $.ScalarType
  ? T extends _std.$json | _std.$decimal | _stdfts.$document | _stdpg.$date | _stdpg.$interval | _stdpg.$json | _stdpg.$timestamp | _stdpg.$timestamptz | _std.$uuid
    ? never
    : T["__tstype__"]
  : T extends $.RangeType
  ? gel.Range<T['__element__']['__tstype__']>
  : T extends $.MultiRangeType
  ? gel.MultiRange<T['__element__']['__tstype__']>
  : never;
export type orScalarLiteral<T extends $.TypeSet> =
  | T
  | ($.BaseTypeSet extends T      ? scalarLiterals      : $.Cardinality extends T["__cardinality__"]        ? getTsType<T["__element__"]>        : $.computeTsTypeCard<            getTsType<T["__element__"]>,            T["__cardinality__"]          >);
export type scalarWithConstType<
  T extends $.ScalarType,
  TsConstType
> = $.ScalarType<
  T["__name__"],
  T["__tstype__"],
  T['__tsargtype__'],
  TsConstType
>;

export type literalToScalarType<T extends any> =
  T extends number ? scalarWithConstType<_std.$number, T> :
  T extends string ? scalarWithConstType<_std.$str, T> :
  T extends boolean ? scalarWithConstType<_std.$bool, T> :
  T extends bigint ? scalarWithConstType<_std.$bigint, T> :
  T extends Uint8Array ? scalarWithConstType<_std.$bytes, T> :
  T extends DateTime ? scalarWithConstType<_std.$datetime, T> :
  T extends gel.Duration ? scalarWithConstType<_std.$duration, T> :
  T extends gel.ConfigMemory ? scalarWithConstType<_cfg.$memory, T> :
  T extends gel.LocalDateTime ? scalarWithConstType<_stdcal.$local_datetime, T> :
  T extends CalendarDate ? scalarWithConstType<_stdcal.$local_date, T> :
  T extends gel.LocalTime ? scalarWithConstType<_stdcal.$local_time, T> :
  T extends gel.RelativeDuration ? scalarWithConstType<_stdcal.$relative_duration, T> :
  T extends gel.DateDuration ? scalarWithConstType<_stdcal.$date_duration, T> :
  T extends gel.Range<infer E> ? $.RangeType<literalToScalarType<E>> :
  T extends gel.MultiRange<infer E> ? $.MultiRangeType<literalToScalarType<E>> :
  never;

type literalToTypeSet<T extends any> = T extends $.TypeSet
  ? T
  : $.$expr_Literal<literalToScalarType<T>>;

export type mapLiteralToTypeSet<T> = {
  [k in keyof T]: literalToTypeSet<T[k]>;
};



function literalToTypeSet(type: any): $.TypeSet {
  if (type && type.__element__) {
    return type;
  }
  if (typeof type === "number") {
    return literal.$getType("00000000-0000-0000-0000-0000000001ff")(type);
  }
  if (typeof type === "string") {
    return literal.$getType("00000000-0000-0000-0000-000000000101")(type);
  }
  if (typeof type === "boolean") {
    return literal.$getType("00000000-0000-0000-0000-000000000109")(type);
  }
  if (typeof type === "bigint") {
    return literal.$getType("00000000-0000-0000-0000-000000000110")(type);
  }
  if (type instanceof Uint8Array) {
    return literal.$getType("00000000-0000-0000-0000-000000000102")(type);
  }
  if (type instanceof DateTime || (type instanceof DateTime && !(type instanceof CalendarDate || type instanceof gel.LocalDate)) || type instanceof Date) {
    return literal.$getType("00000000-0000-0000-0000-00000000010a")(type);
  }
  if (type instanceof gel.Duration) {
    return literal.$getType("00000000-0000-0000-0000-00000000010e")(type);
  }
  if (type instanceof gel.ConfigMemory) {
    return literal.$getType("00000000-0000-0000-0000-000000000130")(type);
  }
  if (type instanceof gel.LocalDateTime) {
    return literal.$getType("00000000-0000-0000-0000-00000000010b")(type);
  }
  if (type instanceof CalendarDate) {
    return literal.$getType("00000000-0000-0000-0000-00000000010c")(type);
  }
  if (type instanceof gel.LocalTime) {
    return literal.$getType("00000000-0000-0000-0000-00000000010d")(type);
  }
  if (type instanceof gel.RelativeDuration) {
    return literal.$getType("00000000-0000-0000-0000-000000000111")(type);
  }
  if (type instanceof gel.DateDuration) {
    return literal.$getType("00000000-0000-0000-0000-000000000112")(type);
  }
  throw new Error(`Cannot convert literal '${type}' into scalar type`);
}


export { getSharedParentScalar, isImplicitlyCastableTo, literalToTypeSet };
