# CYPHER HELP
#
# To find the signature of a procedure so you know what to YIELD:
#
# call dbms.procedures() YIELD name, signature
# where name = "apoc.create.addLabels"
# return signature

# ABSTRACTIONS #############################################################

interface AbstractNode {
  id: ID!
  createdAt: DateTime!
  active: Boolean!
}

type BaseNode {
  id: ID!
  createdAt: DateTime!
  active: Boolean!
  dataHolders: [DataHolder!]! @relation(name: "DATAHOLDERS", direction: "OUT")
  admins: [BaseNode] @relation(name: "ADMINS", direction: "OUT")
  creator: [BaseNode] @relation(name: "CREATOR", direction: "OUT")
  holderCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:DATAHOLDERS]-(h:DataHolder {active: true}) RETURN count(h)
      """
    )
}

enum ValueTypeEnum {
  BOOLEAN
  NUMBER
  STRING
  BASENODE
}

union DataTarget = Data | BaseNode

type DataHolder implements AbstractNode {
  id: ID!
  createdAt: DateTime!
  active: Boolean!
  identifier: String!
  isSingleton: Boolean!
  valueType: ValueTypeEnum!
  baseNode: BaseNode! @relation(name: "DATAHOLDERS", direction: "IN")
  data: [DataTarget] @relation(name: "DATA", direction: "OUT")
  activePropertyCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:DATA]-(d:Data {active:true}) RETURN count(d)
      """
    )
  totalPropertyCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:DATA]-(d:Data) RETURN count(d)
      """
    )
}

type Data implements AbstractNode {
  id: ID!
  createdAt: DateTime!
  active: Boolean!
  value: String!
  dataHolder: DataHolder! @relation(name: "DATA", direction: "IN")
  canRead(requestingUserId: ID): Boolean
    @cypher(
      statement: """
      MATCH (reqUser:User {active: true, id: $requestingUserId})<-[:MEMBERS]-(sg:SecurityGroup{active: true})
      -[:PERMISSIONS]->(perm:Permission{active:true, read: true})-[:GRANT]->(this) RETURN perm.read = true LIMIT 1
      """
    )
}

extend type Mutation {
  addDataOrBaseNodeToDataHolder(fromId: String!, toId: String!): ID
    @cypher(
      statement: """
      MATCH (f {id: $fromId}), (t {id: $toId})
      MERGE (f)-[:DATA]->(t)
      RETURN f.id as id
      """
    )
}

# SECURITY ###############################################################

type SecurityGroup implements AbstractNode {
  id: ID!
  createdAt: DateTime!
  active: Boolean!
  name: String!
  permissions: [Permission] @relation(name: "PERMISSIONS", direction: "OUT")
  powers: [Power] @relation(name: "POWERS", direction: "OUT")
  members: [BaseNode] @relation(name: "MEMBERS", direction: "OUT")
  permissionsCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:PERMISSONS]-(p:Permission {active: true}) RETURN count(p)
      """
    )
  powersCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:POWERS]-(p:Power {active: true}) RETURN count(p)
      """
    )
}

type Permission implements AbstractNode {
  id: ID!
  createdAt: DateTime!
  active: Boolean!
  grantedPropertyName: String!
  read: Boolean
  edit: Boolean
  admin: Boolean
  grant: DataHolder @relation(name: "GRANT", direction: "OUT")
  securityGroup: SecurityGroup @relation(name: "PERMISSIONS", direction: "IN")
}

enum Powers {
  CREATE_SECURITY_GROUP
  DELETE_SECURITY_GROUP
  CREATE_PROJECT
  DELETE_PROJECT
  CREATE_USER
  DELETE_USER
}

type Power implements AbstractNode {
  id: ID!
  createdAt: DateTime!
  active: Boolean!
  value: Powers!
  securityGroup: SecurityGroup @relation(name: "POWERS", direction: "IN")
}

# DATA ##################################################################

extend type Mutation {
  secureUpdateSingletonData(
    baseNodeId: String
    requestingUserId: String
    identifier: String
    newValue: String
    newDataId: String
  ): String
    @cypher(
      statement: """
      MATCH (bn:BaseNode {id:$baseNodeId})

      OPTIONAL MATCH
      (user:User {id: $requestingUserId, active: true})<-[:MEMBERS]-(:SecurityGroup {active:true})-[:PERMISSIONS]->(readPerm:Permission{active:true, edit:true})-[:GRANT]->(dh:DataHolder {active: true, identifier: $identifier})-[:DATA]->(data:Data {active: true})

      SET
      data.active = false

      CREATE
      (dh)-[:DATA]->(newData:Data {id: $newDataId, active: true, value: $newValue, createdAt: datetime()})

      RETURN newData.id
      """
    )

  secureAddArrayData(
    baseNodeId: String
    requestingUserId: String
    identifier: String
    newValue: String
    newDataId: String
  ): String
    @cypher(
      statement: """
      MATCH (bn:BaseNode {id:$baseNodeId})

      OPTIONAL MATCH
      (user:User {id: $requestingUserId, active: true})<-[:MEMBERS]-(:SecurityGroup {active:true})-[:PERMISSIONS]->(readPerm:Permission{active:true, edit:true})-[:GRANT]->(dh:DataHolder {active: true, identifier: $identifier})

      CREATE
      (dh)-[:DATA]->(newData:Data {id: $newDataId, active: true, value: $newValue, createdAt: datetime()})

      RETURN newData.id
      """
    )

  secureUpdateArrayData(
    baseNodeId: String
    requestingUserId: String
    identifier: String
    newValue: String
    oldValue: String
    newDataId: String
  ): String
    @cypher(
      statement: """
      MATCH (bn:BaseNode {id:$baseNodeId})

      OPTIONAL MATCH
      (user:User {id: $requestingUserId, active: true})<-[:MEMBERS]-(:SecurityGroup {active:true})-[:PERMISSIONS]->(readPerm:Permission{active:true, edit:true})-[:GRANT]->(dh:DataHolder {active: true, identifier: $identifier})-[:DATA]->(data:Data {active: true, value: $oldValue})

      SET data.active = false

      CREATE
      (dh)-[:DATA]->(newData:Data {id: $newDataId, active: true, value: $newValue, createdAt: datetime()})

      RETURN newData.id
      """
    )
}

type SingletonPropertyOutput {
  value: String
  canRead: Boolean
  canEdit: Boolean
  canAdmin: Boolean
}

type ArrayPropertyOutput {
  value: [String]
  canRead: Boolean
  canEdit: Boolean
  canAdmin: Boolean
}

extend type Query {
  secureReadDataSingletonByBaseNodeId(
    baseNodeId: String!
    requestingUserId: String!
    identifier: String!
  ): SingletonPropertyOutput
    @cypher(
      statement: """
      MATCH (bn:BaseNode {id:$baseNodeId})

      OPTIONAL MATCH
      (user:User {id: $requestingUserId})<-[:MEMBERS]-(:SecurityGroup {active:true})-[:PERMISSIONS]->(readPerm:Permission{active:true, read:true})-[:GRANT]->(:DataHolder {active: true, identifier: $identifier})-[:DATA]->(data:Data {active: true})

      OPTIONAL MATCH
      (user:User {id: $requestingUserId})<-[:MEMBERS]-(:SecurityGroup {active:true})-[:PERMISSIONS]->(editPerm:Permission{active:true, edit:true})-[:GRANT]->(:DataHolder {active: true, identifier: $identifier})

      OPTIONAL MATCH
      (user:User {id: $requestingUserId})<-[:MEMBERS]-(:SecurityGroup {active:true})-[:PERMISSIONS]->(adminPerm:Permission{active:true, admin:true})-[:GRANT]->(:DataHolder {active: true, identifier: $identifier})

      WITH
      {
        value: data.value,
        canRead: readPerm.read,
        canEdit: editPerm.edit,
        canAdmin: adminPerm.admin
      } as result

      RETURN result
      """
    )

  secureReadDataArrayByBaseNodeId(
    baseNodeId: String!
    requestingUserId: String!
    identifier: String!
  ): ArrayPropertyOutput
    @cypher(
      statement: """
      MATCH (bn:BaseNode {id:$baseNodeId})

      OPTIONAL MATCH
      (user:User {id: $requestingUserId, active: true})<-[:MEMBERS]-(:SecurityGroup {active:true})-[:PERMISSIONS]->(readPerm:Permission{active:true, read:true})-[:GRANT]->(:DataHolder {active: true, identifier: $identifier})-[:DATA]->(data:Data {active: true})

      OPTIONAL MATCH
      (user:User {id: $requestingUserId, active: true})<-[:MEMBERS]-(:SecurityGroup {active:true})-[:PERMISSIONS]->(editPerm:Permission{active:true, edit:true})-[:GRANT]->(:DataHolder {active: true, identifier: $identifier})

      OPTIONAL MATCH
      (user:User {id: $requestingUserId, active: true})<-[:MEMBERS]-(:SecurityGroup {active:true})-[:PERMISSIONS]->(adminPerm:Permission{active:true, admin:true})-[:GRANT]->(:DataHolder {active: true, identifier: $identifier})

      WITH
      {
        value: collect(data.value),
        canRead: readPerm.read,
        canEdit: editPerm.edit,
        canAdmin: adminPerm.admin
      } as result

      RETURN result
      """
    )
}

# LABEL ##########################################

extend type Mutation {
  addLabel(nodeId: String, label: String): String
    @cypher(
      statement: """
      MATCH (n {id:$nodeId})
      CALL apoc.create.addLabels([n], [$label])
      YIELD node
      RETURN node.id
      """
    )
}

# DELETE #############################################

extend type Mutation {
  secureDeleteBaseNode(
    baseNodeId: String!
    requestingUserId: String!
    baseNodeLabel: String!
    power: Powers
  ): Boolean
    @cypher(
      statement: """
      MATCH (baseNode:BaseNode {id:$baseNodeId})

      OPTIONAL MATCH
      (user:User {id: $requestingUserId, active: true})<-[:MEMBERS]-(:SecurityGroup {active:true})-[:POWERS]->(power:Power{active:true, value: $power})

      SET baseNode.active = false

      RETURN baseNode.active as active
      """
    )

  secureDeleteData(
    baseNodeId: String!
    requestingUserId: String!
    identifier: String!
    value: String!
  ): Boolean
    @cypher(
      statement: """
      MATCH (bn:BaseNode {id:$baseNodeId})

      OPTIONAL MATCH
      (user:User {id: $requestingUserId, active: true})<-[:MEMBERS]-(:SecurityGroup {active:true})-[:PERMISSIONS]->(readPerm:Permission{active:true, edit:true})-[:GRANT]->(:DataHolder {active: true, identifier: $identifier})-[:DATA]->(data:Data {active: true, value: $value})

      SET data.active = false

      RETURN data.active as active
      """
    )
}
