module default {
  abstract type Project extending
    Mixin::Postable,
    Comments::Aware,
    Resource,
    Project::ContextAware,
    Mixin::Named,
    Mixin::Pinnable,
    Mixin::Taggable
  {
    type := <Project::Type>.__type__.name[9:-7];

    overloaded name {
      constraint exclusive;
    };

    overloaded required ownSensitivity: Sensitivity {
      annotation description := "The sensitivity of the project. \
        This is user settable for internships and calculated for translation projects";
      default := Sensitivity.High;
    };
    
    departmentId: str {
      constraint exclusive;
      constraint expression on (<int32>__subject__ > 0 and len(__subject__) = 5);
      rewrite insert, update using (
        if (
          not exists .departmentId and
          .status <= Project::Status.Active and
          .step >= Project::Step.PendingFinanceConfirmation
        ) then ((
          with block := (
            if __subject__ is MultiplicationTranslationProject then ((
              with primaryPartnership := assert_exists(
                __subject__.primaryPartnership,
                message := "Project must have a primary partnership"
              )
              select assert_exists(
                primaryPartnership.partner.departmentIdBlock,
                message := "Available Department IDs have not been declared"
              )
            )) else (
              assert_exists(
                assert_exists(
                  __subject__.primaryLocation,
                  message := "Project must have a primary location"
                ).fundingAccount,
                message := "Project's primary location must have a funding account"
              ).departmentIdBlock
            )
          )
          select assert_exists(block.nextAvailable, message := "No department ID is available")
        )) else .departmentId
      );
    };

    required step: Project::Step {
      default := Project::Step.EarlyConversations;
    };
    status := Project::statusFromStep(.step);
    latestWorkflowEvent := (select .workflowEvents order by .at desc limit 1);
    workflowEvents := .<project[is Project::WorkflowEvent];

    trigger assertMatchingLatestWorkflowEvent after insert, update for each do (
      assert(
        __new__.latestWorkflowEvent.to ?= __new__.step
        or (not exists __new__.latestWorkflowEvent and __new__.step = Project::Step.EarlyConversations),
        message := "Project step must match the latest workflow event"
      )
    );

    mouStart: cal::local_date;
    mouEnd: cal::local_date;
    constraint expression on (.mouEnd >= .mouStart);
    initialMouEnd: cal::local_date {
      default := .mouEnd;
      rewrite update using (.mouEnd if .status = Project::Status.InDevelopment else .initialMouEnd);
    }
    
    estimatedSubmission: cal::local_date;
    
    financialReportReceivedAt: datetime;
    financialReportPeriod: ReportPeriod;
    
    multi link members := .<project[is Project::Member];
    single link membership := (select .members filter .user = global default::currentUser limit 1);
    
#     multi link engagements := .<project[is Engagement];
    property engagementTotal := count(.<project[is Engagement]);
    
    primaryLocation: Location;
    trigger enforceFundingAccount after update for each do (
      assert(
        any(__new__.primaryLocation.fundingAccount.accountNumber > 0)
          or not exists __new__.primaryLocation, # allow clearing
        message := "Project must have a primary location with a specified funding account"
      )
    );
    marketingLocation: Location;
    multi otherLocations: Location;
    fieldRegion: FieldRegion;
    marketingRegionOverride: Location;
    
    link rootDirectory: Directory;
    
    partnerships := .<project[is Partnership];
    primaryPartnership := (
      # avoiding backlink here because of partial path resolution bug
      # https://github.com/geldata/gel/issues/8633
      select Partnership
      filter Partnership.primary and Partnership.project = __source__
      limit 1
    );
    
    overloaded link projectContext: Project::Context {
      default := (insert Project::Context {
        # https://github.com/geldata/gel/issues/3960
        # projects := {__subject__},
      });
      on source delete delete target;
    }
    
    trigger createBudgetOnInsert after insert for each do (
      insert default::Budget {
        createdAt := datetime_of_transaction(),
        modifiedAt := datetime_of_transaction(),
        createdBy := assert_exists(global currentActor),
        modifiedBy := assert_exists(global currentActor),
        project := __new__,
        projectContext := __new__.projectContext,
      }
    );

    trigger createPeriodicReports after insert for each 
    when (exists __new__.mouStart and exists __new__.mouEnd)  
    do (
      with
        insertedFinancialReports := Project::create_financial_reports(__new__, 
          <array<FinancialReport>>{}),
        insertedNarrativeReports := Project::create_narrative_reports(__new__,
          <array<NarrativeReport>>{}),
        insertedProgressReports := Project::create_progress_reports(__new__,
          <array<ProgressReport>>{})      
      select <PeriodicReport>{}
    );

    trigger addRemovePeriodicReports after update for each 
      when (
        __old__.mouStart ?!= __new__.mouStart
        or __old__.mouEnd ?!= __new__.mouEnd
        or __old__.financialReportPeriod ?!= __new__.financialReportPeriod
      ) 
      do (
      with
        newMouStart := __new__.mouStart,
        oldMouStart := __old__.mouStart,
        newMouEnd := __new__.mouEnd,
        oldMouEnd := __old__.mouEnd,
        allReportRanges := Project::get_all_report_ranges(__new__),
        financialReports := (
          select default::FinancialReport
          filter .container.id = __old__.id
        ),
        narrativeReports := (
          select default::NarrativeReport
          filter .container.id = __old__.id
        ),
        progressReports := (
          select default::ProgressReport
          filter .container.id = __old__.id
        ),                
        allReports := (
          select PeriodicReport
          filter .container.id = __old__.id
        ),        
        financialReportsForDeletion := (
            select financialReports
            filter not exists .reportFile
        ),                 
        allReportsForDeletion := (
            select allReports
            filter not exists .reportFile
        )
      select
      # start or end date was deleted - delete all reports
      if not exists __new__.mouStart or not exists __new__.mouEnd then (
       for report in allReportsForDeletion
        union (
          delete report
        )
      # financial report period was deleted - delete financial reports
      ) else if not exists __new__.financialReportPeriod then (
        for report in financialReportsForDeletion 
        union (
          delete report
        )
      # start date is moved forward (contraction) - delete all reports that are not in the new range
      ) else if (__new__.mouStart > __old__.mouStart) ?? false then (
        for report in allReportsForDeletion  
        union (
          delete report
          filter report.period not in (allReportRanges)
        )
      # end date is moved backward (contraction) - delete all reports that are not in the new range
      # and add an additional report period range
      ) else if (__new__.mouEnd < __old__.mouEnd) ?? false then (
        with
          deletedReports := (
            for report in allReportsForDeletion  
            union (
              delete report
              filter report.period not in (allReportRanges)
            )),
          additionalReportPeriodRange := (select range(<cal::local_date>newMouEnd, <cal::local_date>newMouEnd, inc_upper := true)),
          insertedFinancialReports := Project::insert_financial_reports(__new__, array_agg(additionalReportPeriodRange)),
          insertedNarrativeReports := Project::insert_narrative_reports(__new__, array_agg(additionalReportPeriodRange)),
          insertedProgressReports := Project::insert_progress_reports(__new__, array_agg(additionalReportPeriodRange))
        select <PeriodicReport>{}
      # financial report period changes - delete all financial reports and insert new ones
      ) else if __old__.financialReportPeriod ?!= __new__.financialReportPeriod then (
        with
          deletedFinancialReports := (
            for report in financialReportsForDeletion 
            union (
              delete report
              filter ( .`start` != .`end` ) # keep additional report (it's still applicable)
            )),
          insertedFinancialReports := Project::create_financial_reports(__new__, array_agg(financialReports))
       select <PeriodicReport>{} 
      # start date is moved backwards (expansion) - insert new reports
      ) else if newMouStart < oldMouStart then (
        with
          insertedFinancialReports := Project::create_financial_reports(__new__, array_agg(financialReports)),
          insertedNarrativeReports := Project::create_narrative_reports(__new__, array_agg(narrativeReports)),
          insertedProgressReports := Project::create_progress_reports(__new__, array_agg(progressReports))
        select <PeriodicReport>{}
      # end date is moved forward (expansion) - delete existing additional report and insert new reports
      ) else if newMouEnd > oldMouEnd then (
        with
          deletedAdditionalReports := (
            for report in allReportsForDeletion
            union (
              delete report
              filter ( .`start` = .`end` )
            )),
          insertedFinancialReports := Project::create_financial_reports(__new__, array_agg(financialReports)),
          insertedNarrativeReports := Project::create_narrative_reports(__new__, array_agg(narrativeReports)),
          insertedProgressReports := Project::create_progress_reports(__new__, array_agg(progressReports))
        select <PeriodicReport>{}
      # nothing changes
      ) else (
        select <PeriodicReport>{}
      )
    );
  }
  
  abstract type TranslationProject extending Project {
    multi link engagements := .<project[is LanguageEngagement];
    multi link languages := .engagements.language;
    
    trigger confirmProjectSens after update for each do (
      assert(
        __new__.ownSensitivity = max(__new__.languages.ownSensitivity) ?? Sensitivity.High,
        message := "TranslationProject sensitivity is automatically set to \
          (and required to be) the highest sensitivity Language engaged"
      )
    );
  }

  type MomentumTranslationProject extending TranslationProject;
  type MultiplicationTranslationProject extending TranslationProject;
  
  type InternshipProject extending Project {
    multi link engagements := .<project[is InternshipEngagement];
  }
}
 
module Project {
  abstract type Child extending default::Resource, ContextAware {
    annotation description := "\
      A type that is a child of a project. \
      It will always have a reference to a single project that it is under.";
    
    required project: default::Project {
      readonly := true;
      on target delete delete source;
    };
    
    trigger enforceCorrectProjectContext after insert, update for each do (
      assert(
        __new__.projectContext = __new__.project.projectContext,
        message := "Given project context must match given project's context"
      )
    );
  }
  
  abstract type ContextAware {
    annotation description := "\
      A type that has a project context, which allows it to be
      aware of the sensitivity & current user membership for the associated context.";
    
    required projectContext: Context {
      on target delete delete source;
    }
    index on (.projectContext);
    
    optional ownSensitivity: default::Sensitivity {
      annotation description := "\
        A writable source of a sensitivity. \
        This doesn't necessarily mean it be the same as .sensitivity, which is what is used for authorization.";
    };
    
    required single property sensitivity :=
      max(.projectContext.projects.ownSensitivity)
      ?? (.ownSensitivity ?? default::Sensitivity.High);
    required single property isMember := exists .projectContext.projects.membership;
  }
  
  scalar type Type extending enum<
    MomentumTranslation,
    MultiplicationTranslation,
    Internship
  >;

  type FinancialApprover {
    required user: default::User {
      constraint exclusive;
    };
    required multi projectTypes: Type;
  }
  
  type Context {
    annotation description := "\
      A type that holds a reference to a list of projects. \
      This allows multiple objects to hold a reference to the same list. \
      For example, Language & Ethnologue::Language share the same context / project list.";
    
    multi projects: default::Project {
      on target delete allow;
    };
  }

  # creates the ranges for the given start and end dates based upon the given month interval,
  # and creates a single additional range that is bound by the given end date, with the upper 
  # bound inclusive
  function create_periodic_report_ranges(project: default::Project, monthInterval: str) 
    -> set of range<cal::local_date>
    using (
      select
      if not exists project.mouStart or not exists project.mouEnd or not exists monthInterval then (
        select <range<cal::local_date>>{}
      ) else ( 
        with
          reportingPeriod := range(<cal::local_date>project.mouStart, <cal::local_date>project.mouEnd),
          reportPeriodStartDates := range_unpack(reportingPeriod, <cal::date_duration>(monthInterval ++ ' month')),
          reportPeriodRanges := (
            for firstDayOfMonth in reportPeriodStartDates
            union (
              with
                firstDayOfNextPeriod := (select firstDayOfMonth + <cal::relative_duration>(monthInterval ++ ' month')),
              select range(<cal::local_date>firstDayOfMonth, <cal::local_date>firstDayOfNextPeriod)
            )
          ),
          additionalReportPeriodRange := (select range(<cal::local_date>project.mouEnd, <cal::local_date>project.mouEnd, inc_upper := true))
        select reportPeriodRanges union additionalReportPeriodRange
      )
  );

  function get_all_report_ranges(project: default::Project) -> set of range<cal::local_date> {
    using (
      with
        monthlyReportRanges := (
          select Project::create_periodic_report_ranges(assert_exists(project), '1')
        ),        
        quarterlyReportRanges := (
          select Project::create_periodic_report_ranges(assert_exists(project), '3')
        )
      select monthlyReportRanges union quarterlyReportRanges
    );
  }

  function determine_requested_report_periods(monthInterval: str, newProject: default::Project,
    existingReports: optional array<default::PeriodicReport>) -> set of range<cal::local_date> {
    volatility := 'Modifying';
    using (
      with
        requestedReportPeriods := Project::create_periodic_report_ranges(newProject, monthInterval),
        distinctRequestedReportPeriods := distinct requestedReportPeriods
      select
      if exists existingReports then (
        with
          newReportPeriodsOnly := (
            select distinctRequestedReportPeriods
            # filter out report periods that already exist in current reports
            filter distinctRequestedReportPeriods not in (
              for report in array_unpack(existingReports)
              select report.period
            )
          ),
        select newReportPeriodsOnly
      ) else (
        select distinctRequestedReportPeriods
      )
    );
  }

  function create_financial_reports(newProject: default::Project,    
    financialReports: optional array<default::FinancialReport>) -> set of default::FinancialReport
    using (
      select
      if exists newProject.financialReportPeriod then (
        with
          periodsForInsertion := (
            select
            if newProject.financialReportPeriod ?= default::ReportPeriod.Monthly then (
              select Project::determine_requested_report_periods(
                 '1',
                  newProject,
                  financialReports
                )
            ) else (
              select Project::determine_requested_report_periods(
                '3',
                newProject,
                financialReports
              ) 
            )
          ),
          project := newProject
        select Project::insert_financial_reports(project, array_agg(periodsForInsertion))
      ) else (
        select <default::FinancialReport>{}
      )
    );

  function create_narrative_reports(newProject: default::Project,
    narrativeReports: optional array<default::NarrativeReport>) -> set of default::NarrativeReport
    using (
      with
        periodsForInsertion := Project::determine_requested_report_periods(
          '3',
          newProject,
          narrativeReports
        )
        select Project::insert_narrative_reports(newProject, array_agg(periodsForInsertion))
    );

  function create_progress_reports(newProject: default::Project,
    progressReports: optional array<default::ProgressReport>) -> set of default::ProgressReport
    using (
      with
        periodsForInsertion := Project::determine_requested_report_periods(
          '3',
          newProject,
          progressReports
        )
        select Project::insert_progress_reports(newProject, array_agg(periodsForInsertion))
    );

  function insert_financial_reports(newProject: default::Project,
    periodsForInsertion: array<range<cal::local_date>>) -> set of default::FinancialReport
    using (
      for reportPeriod in array_unpack(periodsForInsertion)
      union (
        insert default::FinancialReport {
          createdAt := datetime_of_statement(),
          modifiedAt := datetime_of_statement(),
          createdBy := assert_exists(global default::currentActor),
          modifiedBy := assert_exists(global default::currentActor),
          project := newProject,
          projectContext := newProject.projectContext,
          container := newProject,
          period := reportPeriod,
        }
      )
    );

  function insert_narrative_reports(newProject: default::Project,
    periodsForInsertion: array<range<cal::local_date>>) -> set of default::NarrativeReport
    using (
      for reportPeriod in array_unpack(periodsForInsertion)
      union (
        insert default::NarrativeReport {
          createdAt := datetime_of_statement(),
          modifiedAt := datetime_of_statement(),
          createdBy := assert_exists(global default::currentActor),
          modifiedBy := assert_exists(global default::currentActor),
          project := newProject,
          projectContext := newProject.projectContext,
          container := newProject,
          period := reportPeriod,
        }
      )
    );

  function insert_progress_reports(newProject: default::Project,
    periodsForInsertion: array<range<cal::local_date>>) -> set of default::ProgressReport
    using (
      with
        projectWithEngagements := (
          select newProject {
            engagements := .<project[is default::LanguageEngagement]
          }
        )
      select (
        for reportPeriod in array_unpack(periodsForInsertion)
        union (
          for engagement in projectWithEngagements.engagements
          union (
            insert default::ProgressReport {
              createdAt := datetime_of_statement(),
              modifiedAt := datetime_of_statement(),
              createdBy := assert_exists(global default::currentActor),
              modifiedBy := assert_exists(global default::currentActor),
              project := newProject,
              projectContext := newProject.projectContext,
              engagement := engagement,
              container := engagement,
              period := reportPeriod,
            }
          )
        )
      )
    );
}
